

pub struct Tree {
    left:Option<Box<Tree>>,
    right:Option<Box<Tree>>,
    root:i32,
}

impl Tree {
    fn new(root:i32) -> Tree {
        Tree{
            root:root,
            left:None,
            right:None
        }


    }

    fn insert_left(&mut self,leaf:Tree){
        self.left = Some(Box::new(leaf));
        
    }

    fn insert_right(&mut self,leaf:Tree) {
        self.right = Some(Box::new(leaf));
        
    }

}

pub fn print_leaf_nodes(tree:&Tree){
    println!("start recurse!");
    match &tree.left {
        None =>{
            println!("empty left node");
        },
        Some(n) => {
            println!("Found sub node");
            print_leaf_nodes(&n);
        }
    }

    match &tree.right {
        None => {
            println!("Found empty right node");
        },
        Some(n) => {
            println!("Found some right lets recurse");
            print_leaf_nodes(&n);
        }
    }
    println!("leaf: {}",tree.root);


}




fn main() {
    println!("Hello, world!");
    let mut tt = Tree::new(7);
    tt.insert_left(Tree::new(6));
    tt.insert_right(Tree::new(8));

    //println!("left value is {}",tt.left.unwrap().left.unwrap().root)
    print_leaf_nodes(&tt);
                       
}
